"""
ооп базовое:
Зачем нужен объект(класс)? - чтобы делать то и это
 - создаем класс с такими методами.

"""


"""
класс property, @property
------------------------------
class property(fget=None, fset=None, fdel=None, doc=None) from builtins
декоратор @property позволяет работать с методом некоторого класса как с атрибутом.
В результате преобразования метода в свойство доступ к нему осуществляется с помощью 
обычной точечной нотации, без скобок


def __new__(cls):  # методом можно создать экз класса(cls)
"""
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

"""
Абстрактный метод:
-------------------------------
from abc import ABC, abstractmethod 
это метод абстрактного класса кот должен быть переопределен у наследников.
Абстрактный класс: 
(должен наследоваться от ABC) определяет какие методы должны быть у наследников.
Это интерфейс для подклассов(класс с набором абс методов, но без реализации)
не может быть инстанциирован, от него нужно наследоваться 
и переопределить его абс методы.

на заметку:
если класс имеет абстрактные методы, но не наследуется от abc.ABC, 
то он не абстрактный - инстанциируется без ошибки.
если наследуется от abc.ABC, может иметь и обычные и абстрактные методы(@abstractmethod )


Метод экземпляра класса:
---------------------------------
первым аргументом принимает self(указывает на сам экземпляр)
может менять состояние и экземпляра,
и самого класса(через self.__class__)


Статический метод - @staticmethod:
--------------------------------------------
обычная функция, кот принадлежит к области видимости класса, 
не имеет доступа к методам и свойствам экземпляров класса, тк не видит сами экземпляры
сам статический метод не знает кто он и откуда
не может изменять ни класс, ни его экземпляр:
class A:
    @staticmethod
    def meth():
        print('meth')
a = A()
meth()  # ошибка! область видимости класса!
статик метод один на все инстансы класса
A.meth()  # стат метод можно вызвать от самого класса
a.meth()  # а можно вызвать от инстанса класса (по сути-от самого класса)
# вызвать то можно, но поменять у инстанса он ничего не сможет!
# те мы говорим: вызвать метод meth() из класса А которому принадлежит инстанс а


Метод класса - @classmethod:
--------------------------------------
первым аргументом принимает cls(указывает на текущий класс)
привязан к классу, а не его экземпляру. 
может менять класс(отразится на всех его объектах), 
но не может менять экземпляр.
используется обычно в кач метода генерирующего экземпляр класса.
class MyClass:
    def method(self):
        return 'instance method called', self

    @classmethod
    def classmethod(cls):
        return 'class method called', cls


абстракция 
---------------
набор ключевых характеристик(телефон звонит, его цвет неважен)


инкапсуляция
=====================================================================================
упаковка методов и атрибутов вместе(в классе)
помещение в капсулу - помещение в класс.
а также сокрытие внутренней реализации класса и предоставление 
интерфейсов для взаимодействия с ним извне.
(внутри класса может что-то поменяться но на внешнем взаимодействии это не отразится)
все объекты питона инкапсулируют в себе данные и методы для работы с ними.
позволяет работать с объектами не зная как они устроены внутри.	
для java это также сокрытие сущностей класса от изменений извне,
но в python такого сокрытия нет, но его можно имитировать через модификаторы доступа.

модификаторы доступа
-------------------------
изменяют обл видимости методов и свойств объекта.
public - свойства и методы объектов доступны напрямую извне
__private - по соглашению, доступ только внутри текущего класса (обход: B._B__count) 
    name mangling: было __count стало _B__count - python привязывает метод к имени класса
_protected - по соглашению, доступ из самого объекта, или его потомков

геттеры(аксессоры), сеттеры(mutator), деструкторы
--------------------------------------------------------
это интерфейсы для доступа к частным свойствам и методам объекта извне
(чтобы не напрямую) и проверки корректности данных:
создаем эти методы вручную.
можно перегрузить __getattr__, __setattr__ и __delattr__
для настоящей защиты приватных методов есть модуль: pip install accessify

"""

"""
наследование
================================================================================== 
отношение "есть" - Собака есть Животное
дочерние классы наследуют атрибуты и методы родительских,
могут их переопределять и расширять.
"""


class Table:
    def __init__(self, l=1, w=2, h=3):  # в конструкторе класса инициализируются параметры l, w, h
        self.length = l
        self.width = w
        self.height = h


class KitchenTable(Table):
    def __init__(self, l, w, h, p):  # определяем конструктор с необходимыми атрибутами
        super().__init__(l, w, h)  # наследуем родительский конструктор с его атрибутами
        # те говорим что берем атрибуты кот уже определены в родительском классе
        # Table.__init__(self, l, w, h) - вот что происходит
        self.places = p


class KitchenTable2(Table):
    # если в родителе параметры заданы по умолчанию, то дочернему их можно не передавать:
    def __init__(self, p):  # только новый параметр p
        super().__init__()  # автоматом берем атрибуты кот уже определены в родительском классе
        self.places = p


kt = KitchenTable2(10)
print(kt.length, kt.width, kt.height, kt.places)  # 1 2 3 10

"""
__init__ конструктор класса отвечает за создание экземпляра класса.
__init__() - это метод инициализации класса, 
super().__init__() вызывает метод инициализации родительского класса,
чтобы дополнить его или изменить.


Every time you use super() in a method, you need to be in an instance 
method or a class method. Your staticmethods don't know what their 
superclasses are. К super() можно обращаться из метода экземпляра или из
метода класса, (или из класса наследника, того в котором определен стат метод)
а статический метод не знает кто его родитель.

super(), возвращает объект объект-посредник, который делегирует вызовы 
метода родительскому или родственному классу
Будучи вызванным без параметров внутри какого-либо класса, super() вернет прокси-объект, 
методы которого будут искаться только в классах, стоящих ранее, чем он, в порядке MRO. 
То есть, это будет как будто бы тот же самый объект, но он будет игнорировать все 
определения из текущего класса, обращаясь только к родительским.

Переопределение метода:
Используется также если в дочернем классе перегружен метод родителя а надо вызвать родительский: 
super().some_method()
С помощью super().some_method() мы вызвали родительский метод, а после дополнили свой.
или просто вызвать метод из родителя:
class B(A):
    def foo(self):
        super().foo()   # calls 'A.foo()'


множественное наследование - 
наследовать функционал не от одного, а от нескольких родителей
используется для создания миксинов.

MRO - Method Resolution Order - порядок разрешения методов
первым ищет в классе кот первым идет в списке наследований.
для определения порядка используется алгоритм поиска в ширину ??
сначала ищет в детях, потом в родителях
сначала в левых родителях потом в правых
MRO класса можно просмотреть в атрибуте __mro__ или с помощью метода mro():
ClassName__mro__ или class_instance.__class__.mro()
"""

"""
полиморфизм
==================================================================================
возможность исп один интерфейс для для разных классов и типов данных
одноименный метод у разных классов выполняет разные действия
(метод say для кошки и собаки)
можно использовать не задумываясь к какому классу принадлежит объект:
сложить два числа или две строки.


ассоциация
===================================================================================
отношение "содержит" - Автомобиль содержит Двигатель
два вида: агрегация(экз класса А получает ранее созданный экз класса B)
          композиция(экз класса А создает в себе экз класса B; b не имеет смысла вне a)
один класс является полем другого


Метаклассы
это классы, инстансы которых тоже являются классами








Абстрактный тип данных
это тип данных который определяется из его поведения и возможных операций над ним(вики)
"""





# Объекты представлений являются итерируемыми, т.е. они генерируют результирующие
# элементы по одному за раз, а не производят сразу весь результирующий список в
# памяти.
# циклические конструкции в Python автоматически заставляют итерируемые объекты выдавать по одному
# результату на каждой итерации: